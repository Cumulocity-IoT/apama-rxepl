package com.industry.rx_epl;

using com.apama.exceptions.Exception;

using com.industry.rx_epl.operators.Amb;
using com.industry.rx_epl.operators.Async;
using com.industry.rx_epl.operators.Average;
using com.industry.rx_epl.operators.AverageDecimal;
using com.industry.rx_epl.operators.Buffer;
using com.industry.rx_epl.operators.BufferCount;
using com.industry.rx_epl.operators.BufferCountSkip;
//using com.industry.rx_epl.operators.BufferTime;
using com.industry.rx_epl.operators.BufferTimeOrCount;
using com.industry.rx_epl.operators.CatchError;
using com.industry.rx_epl.operators.CombineLatest;
using com.industry.rx_epl.operators.CombineLatestToSequence;
using com.industry.rx_epl.operators.Concat;
using com.industry.rx_epl.operators.ConcatString;
using com.industry.rx_epl.operators.Contains;
using com.industry.rx_epl.operators.Count;
//using com.industry.rx_epl.operators.Debounce;
using com.industry.rx_epl.operators.DefaultIfEmpty;
using com.industry.rx_epl.operators.Delay;
using com.industry.rx_epl.operators.Distinct;
using com.industry.rx_epl.operators.DistinctBy;
using com.industry.rx_epl.operators.DistinctByUntilChanged;
using com.industry.rx_epl.operators.DistinctUntilChanged;
using com.industry.rx_epl.operators.Do;
using com.industry.rx_epl.operators.ElementAt;
using com.industry.rx_epl.operators.Every;
using com.industry.rx_epl.operators.Filter;
using com.industry.rx_epl.operators.First;
using com.industry.rx_epl.operators.FlatMap;
//using com.industry.rx_epl.operators.GroupBy;
//using com.industry.rx_epl.operators.GroupByWindow;
using com.industry.rx_epl.operators.IgnoreElements;
using com.industry.rx_epl.operators.Last;
using com.industry.rx_epl.operators.Map;
using com.industry.rx_epl.operators.Max;
using com.industry.rx_epl.operators.MaxDecimal;
using com.industry.rx_epl.operators.MaxFloat;
using com.industry.rx_epl.operators.MaxInteger;
using com.industry.rx_epl.operators.Min;
using com.industry.rx_epl.operators.MinDecimal;
using com.industry.rx_epl.operators.MinFloat;
using com.industry.rx_epl.operators.MinInteger;
using com.industry.rx_epl.operators.Merge;
using com.industry.rx_epl.operators.MergeAll;
using com.industry.rx_epl.operators.Pipe;
using com.industry.rx_epl.operators.Pluck;
using com.industry.rx_epl.operators.Reduce;
using com.industry.rx_epl.operators.ReduceWithInitial;
using com.industry.rx_epl.operators.Repeat;
using com.industry.rx_epl.operators.Retry;
//using com.industry.rx_epl.operators.Sample;
//using com.industry.rx_epl.operators.SampleCount;
//using com.industry.rx_epl.operators.SampleTime;
//using com.industry.rx_epl.operators.SampleTimeOrCount;
using com.industry.rx_epl.operators.Scan;
using com.industry.rx_epl.operators.ScanWithInitial;
using com.industry.rx_epl.operators.SequenceEqual;
using com.industry.rx_epl.operators.Skip;
using com.industry.rx_epl.operators.SkipLast;
using com.industry.rx_epl.operators.SkipUntil;
using com.industry.rx_epl.operators.SkipWhile;
using com.industry.rx_epl.operators.StartWith;
using com.industry.rx_epl.operators.Sum;
using com.industry.rx_epl.operators.SumDecimal;
using com.industry.rx_epl.operators.SumFloat;
using com.industry.rx_epl.operators.SumInteger;
using com.industry.rx_epl.operators.SwitchMap;
using com.industry.rx_epl.operators.SwitchOnNext;
using com.industry.rx_epl.operators.Take;
using com.industry.rx_epl.operators.TakeLast;
using com.industry.rx_epl.operators.TakeUntil;
using com.industry.rx_epl.operators.TakeWhile;
using com.industry.rx_epl.operators.ThrottleFirst;
using com.industry.rx_epl.operators.ThrottleLast;
using com.industry.rx_epl.operators.TimeInterval;
using com.industry.rx_epl.operators.Timeout;
using com.industry.rx_epl.operators.Timestamp;
using com.industry.rx_epl.operators.UpdateTimestamp;
using com.industry.rx_epl.operators.WithLatestFrom;
using com.industry.rx_epl.operators.WithLatestFromToSequence;
//using com.industry.rx_epl.operators.WindowCount;
//using com.industry.rx_epl.operators.WindowTime;
//using com.industry.rx_epl.operators.WindowTimeOrCount;
using com.industry.rx_epl.operators.Zip;
using com.industry.rx_epl.operators.ZipToSequence;

using com.industry.rx_epl.operators.internals.CreateOnConnection;
using com.industry.rx_epl.operators.internals.DebounceHandler;
using com.industry.rx_epl.operators.internals.EmptyNeverError;
using com.industry.rx_epl.operators.internals.FromChannelOnConnection;
using com.industry.rx_epl.operators.internals.FromIteratorOnConnection;
using com.industry.rx_epl.operators.internals.FromStreamOnConnection;
using com.industry.rx_epl.operators.internals.FromOnConnection;
using com.industry.rx_epl.operators.internals.GetSyncHandler;
using com.industry.rx_epl.operators.internals.GroupByOnConnection;
using com.industry.rx_epl.operators.internals.IntervalOnConnection;
using com.industry.rx_epl.operators.internals.JustOnConnection;
using com.industry.rx_epl.operators.internals.ObserveOnHandler;
using com.industry.rx_epl.operators.internals.PublishHandler;
using com.industry.rx_epl.operators.internals.PublishReplayHandler;
using com.industry.rx_epl.operators.internals.ObserveToHandler;
using com.industry.rx_epl.operators.internals.RangeOnConnection;
using com.industry.rx_epl.operators.internals.ObserveFromDispose;
using com.industry.rx_epl.operators.internals.ObserveFromOnConnection;
using com.industry.rx_epl.operators.internals.RefCountOnConnection;
using com.industry.rx_epl.operators.internals.SampleMapper;
using com.industry.rx_epl.operators.internals.StartOnConnection;
using com.industry.rx_epl.operators.internals.SubscribeOnConnection;
using com.industry.rx_epl.operators.internals.ToStream;
using com.industry.rx_epl.operators.internals.WindowCountOnConnection;
using com.industry.rx_epl.operators.internals.WindowOnConnection;
using com.industry.rx_epl.operators.internals.WindowTimeOrCountOnConnection;

event Observable {	
	action<IObserver> returns ISubscription onConnection;
	
	boolean connectable;
	IDisposable connection;
	
	action<> returns IDisposable connect;
	
	static action _create() returns Observable {
		Observable o := new Observable;
		o.connect := invalidConnect;
		return o;
	}
	static action _createAsIObservable() returns IObservable {
		Observable o := new Observable;
		o.connect := invalidConnect;
		return o.asIObservable();
	}
	
	static action _createConnectable(IDisposable connection, action<> returns IDisposable connect) returns Observable {
		Observable o := new Observable;
		o.connect := connect;
		o.connectable := true;
		o.connection := connection;
		return o;
	}

	static action create(action<IResolver> resolver) returns IObservable {
		// A user defined resolver cannot handle pull requests so it's hot
		Observable o := _create();
		o.onConnection := CreateOnConnection.create(resolver);
		return o.asIObservable();
	}

	static action fromValues(any values) returns IObservable {
		Observable o := _create();
		o.onConnection := FromOnConnection.create(values);
		return o.asIObservable();
	}
	
	static action fromIterator(action<> returns any iterator) returns IObservable {
		Observable o := _create();
		o.onConnection := FromIteratorOnConnection.create(iterator);
		return o.asIObservable();
	}
	
	static action just(any value) returns IObservable {
		Observable o := _create();
		o.onConnection := JustOnConnection.create(value);
		return o.asIObservable();		
	}
	
	/**
	 * Note: the channel listener start asynchronously - so won't receive events until a short time later
	 */
	static action fromChannel(string channelName) returns IObservable {
		Observable o := _create();
		o.onConnection := FromChannelOnConnection.create(channelName);
		return o.asIObservable();		
	}

	/**
	 * Generates a series of event with an incrementing float value
	 * @param interval the time between subsequent events
	 */
	static action interval(float seconds) returns IObservable {
		Observable o := _create();
		o.onConnection := IntervalOnConnection.create(seconds);
		return o.asIObservable();	
	}
	
	static action range(integer start, integer end) returns IObservable {
		Observable o := _create();
		o.onConnection := RangeOnConnection.create(start, end);
		return o.asIObservable();	
	}
	
	static action repeat(any value, integer count) returns IObservable {
		Observable j := <Observable> just(value).observable;
		return j.repeatObservable(count);
	}
	
	static action combineLatest(sequence<IObservable> observables, action<sequence<any> > returns any combiner) returns IObservable {
		IObservable first := observables[0];
		
		sequence<IObservable> others := (new sequence<IObservable>);
		others.appendSequence(observables);
		others.remove(0);
		
		return first.combineLatest(others, combiner);
	}
	
	static action start(action<> returns any valueGenerator) returns IObservable {
		Observable o := _create();
		o.onConnection := StartOnConnection.create(valueGenerator);
		return o.asIObservable();
	}
	
	static action merge(sequence<IObservable> observables) returns IObservable {
		IObservable first := observables[0];
		
		sequence<IObservable> others := (new sequence<IObservable>);
		others.appendSequence(observables);
		others.remove(0);
		
		return first.merge(others);
	}
	
	static action zip(sequence<IObservable> observables, action<sequence<any> > returns any combiner) returns IObservable {
		IObservable first := observables[0];
		
		sequence<IObservable> others := (new sequence<IObservable>);
		others.appendSequence(observables);
		others.remove(0);
		
		return first.zip(others, combiner);
	}
	
	static action fromStream(stream<any> valueStream) returns IObservable {
		Observable o := _create();
		o.onConnection := FromStreamOnConnection.create(valueStream);
		return o.asIObservable();
	}
	
	static action timer(any value, float delay) returns IObservable {
		return just(value).delay(delay);
	}

	static action observeFromChannel(string channelName) returns IObservable {
		Observable o := _create();
		o.onConnection := ObserveFromOnConnection.create(channelName);
		return o.asIObservable();
	}
	
	static action concat(sequence<IObservable> observables) returns IObservable {
		IObservable first := observables[0];
		
		sequence<IObservable> others := (new sequence<IObservable>);
		others.appendSequence(observables);
		others.remove(0);
		
		return first.concat(others);
	}

	static action empty() returns IObservable {
		return create(EmptyNeverError.emptyGenerator);
	}
	
	static action never() returns IObservable {
		return create(EmptyNeverError.neverGenerator);
	}
	
	static action error() returns IObservable {
		return create(EmptyNeverError.errorGenerator);
	}
	
	static action sequenceEqual(sequence<IObservable> observables) returns IObservable {
		IObservable first := observables[0];
		
		sequence<IObservable> others := (new sequence<IObservable>);
		others.appendSequence(observables);
		others.remove(0);
		
		return first.sequenceEqual(others);
	}
	
	static action amb(sequence<IObservable> observables) returns IObservable {
		IObservable first := observables[0];
		
		sequence<IObservable> others := (new sequence<IObservable>);
		others.appendSequence(observables);
		others.remove(0);
		
		return first.amb(others);
	}
	
	static action combineLatestToSequence(sequence<IObservable> observables) returns IObservable {
		IObservable first := observables[0];
		
		sequence<IObservable> others := (new sequence<IObservable>);
		others.appendSequence(observables);
		others.remove(0);
		
		return first.combineLatestToSequence(others);
	}
	
	static action zipToSequence(sequence<IObservable> observables) returns IObservable {
		IObservable first := observables[0];
		
		sequence<IObservable> others := (new sequence<IObservable>);
		others.appendSequence(observables);
		others.remove(0);
		
		return first.zipToSequence(others);
	}
	
	action connectObserver(IObserver observer) returns ISubscription {
		return onConnection(observer);
	}
	
	action subscribe(Subscriber subscriber) returns ISubscription {
		Observable o := _create();
		
		IObserver observer := subscriber.asIObserver();

		o.onConnection := SubscribeOnConnection.create(onConnection); 
		
		return o.onConnection(observer);
	}
	
	action map(action<any> returns any mapper) returns IObservable {
		Observable o := _create();		
		o.onConnection := Map.create(mapper)(onConnection);
		return o.asIObservable();
	}
	
	action publish() returns IObservable {
		IDisposable connection := IDisposable(new action<>);
		PublishHandler p := PublishHandler.create(onConnection, connection);
		Observable o := _createConnectable(connection, p.connect);
		
		o.onConnection := p.onConnection;
		
		return o.asIObservable();
	}
	
	action refCount() returns IObservable {
		if not connectable {
			throw Exception("Can only refCount a published Observable", "UnsupportedOperation");
		}
		Observable o := _create();
		o.onConnection := RefCountOnConnection.create(connection, connect, onConnection);
		return o.asIObservable();
	}
	
	action share() returns IObservable {
		return publish().refCount();
	}

	action take(integer count) returns IObservable {
		Observable o := _create();
		o.onConnection := Take.create(count)(onConnection);
		return o.asIObservable();	
	}

	action takeLast(integer count) returns IObservable {
		Observable o := _create();
		o.onConnection := TakeLast.create(count)(onConnection);
		return o.asIObservable();	
	}

	action first() returns IObservable {
		Observable o := _create();
		o.onConnection := First.create()(onConnection);
		return o.asIObservable();	
	}
	
	action last() returns IObservable {
		Observable o := _create();
		o.onConnection := Last.create()(onConnection);
		return o.asIObservable();	
	}
	
	action skip(integer count) returns IObservable {
		Observable o := _create();
		o.onConnection := Skip.create(count)(onConnection);
		return o.asIObservable();			
	}

	action skipLast(integer count) returns IObservable {
		Observable o := _create();
		o.onConnection := SkipLast.create(count)(onConnection);
		return o.asIObservable();			
	}
	
	action filter(action<any> returns boolean predicate) returns IObservable {
		Observable o := _create();
		o.onConnection := Filter.create(predicate)(onConnection);
		return o.asIObservable();			
	}

	action scan(action<any, any> returns any scanner) returns IObservable {
		Observable o := _create();
		o.onConnection := Scan.create(scanner)(onConnection);
		return o.asIObservable();		
	}
	
	action scanWithInitial(action<any, any> returns any scanner, any initialValue) returns IObservable {
		Observable o := _create();
		o.onConnection := ScanWithInitial.create(scanner, initialValue)(onConnection);
		return o.asIObservable();		
	}
	
	action distinct() returns IObservable {
		Observable o := _create();
		o.onConnection := Distinct.create()(onConnection);
		return o.asIObservable();		
	}
	
	action distinctBy(action<any> returns any by) returns IObservable {
		Observable o := _create();
		o.onConnection := DistinctBy.create(by)(onConnection);
		return o.asIObservable();			
	}
	
	action combineLatestFromInstance(sequence<IObservable> otherObservables, action<sequence<any> > returns any combiner) returns IObservable {
		Observable o := _create();
		o.onConnection := CombineLatest.create(otherObservables, combiner)(onConnection);
		return o.asIObservable();
	}
	
	action withLatestFrom(sequence<IObservable> otherObservables, action<sequence<any> > returns any combiner) returns IObservable {
		Observable o := _create();
		o.onConnection := WithLatestFrom.create(otherObservables, combiner)(onConnection);
		return o.asIObservable();
	}
	
	action delay(float seconds) returns IObservable {
		Observable o := _create();
		o.onConnection := Delay.create(seconds)(onConnection);
		return o.asIObservable();
	}
	
	action async() returns IObservable {
		Observable o := _create();
		o.onConnection := Async.create()(onConnection);
		return o.asIObservable();
	}
	
	action do(Subscriber doer) returns IObservable {
		Observable o := _create();
		o.onConnection := Do.create(doer)(onConnection);
		return o.asIObservable();
	}
	
	/**
	 * Note: on termination of the connection the replay buffer will be emptied
	 */
	action publishReplay(integer count) returns IObservable {
		IDisposable connection := IDisposable(new action<>);
		
		Observable publishObservable := <Observable> publish().observable;
		PublishReplayHandler replayHandler := PublishReplayHandler.create(publishObservable.connection, connection, publishObservable.connect, publishObservable.onConnection, count);
		Observable o := _createConnectable(connection, replayHandler.downstreamConnect);
		
		o.onConnection := replayHandler.onConnection;
		
		return o.asIObservable();
	}
	
	/**
	 * Note: Unlike in rxjs v5.5 (but like rxjs v5.4) - if the refcount drops to 0 then the source will be disconnected from and the replay buffer will be emptied
	 */
	action shareReplay(integer count) returns IObservable {
		return publishReplay(count).refCount();
	}
	
	action takeUntil(IObservable until) returns IObservable {
		Observable o := _create();
		o.onConnection := TakeUntil.create(until)(onConnection);
		return o.asIObservable();
	}
	
	// Called repeat when accessed via the interface
	action repeatObservable(integer count) returns IObservable {
		Observable o := _create();
		o.onConnection := Repeat.create(count)(onConnection);
		return o.asIObservable();
	}
	
	action flatMap(action<any> returns any mapper) returns IObservable {
		Observable o := _create();
		o.onConnection := FlatMap.create(mapper)(onConnection);
		return o.asIObservable();
	}
	
	action mergeFromInstance(sequence<IObservable> otherObservables) returns IObservable {
		Observable o := _create();
		o.onConnection := Merge.create(otherObservables)(onConnection);
		return o.asIObservable();
	}
	
	action zipFromInstance(sequence<IObservable> otherObservables, action<sequence<any> > returns any combiner) returns IObservable {
		Observable o := _create();
		o.onConnection := Zip.create(otherObservables, combiner)(onConnection);
		return o.asIObservable();
	}
	
	action switchOnNext() returns IObservable {
		Observable o := _create();
		o.onConnection := SwitchOnNext.create()(onConnection);
		return o.asIObservable();
	}
	
	action skipUntil(IObservable until) returns IObservable {
		Observable o := _create();
		o.onConnection := SkipUntil.create(until)(onConnection);
		return o.asIObservable();
	}
	
	action elementAt(integer n) returns IObservable {
		Observable o := _create();
		o.onConnection := ElementAt.create(n)(onConnection);
		return o.asIObservable();
	}
	
	action reduce(action<any, any> returns any reducer) returns IObservable {
		Observable o := _create();
		o.onConnection := Reduce.create(reducer)(onConnection);
		return o.asIObservable();
	}
	
	action reduceWithInitial(action<any, any> returns any reducer, any initialValue) returns IObservable {
		Observable o := _create();
		o.onConnection := ReduceWithInitial.create(reducer, initialValue)(onConnection);
		return o.asIObservable();
	}
	
	/**
	 * The stream will automatically quit and dispose if/when the observable does.
	 * It is necessary to call dispose on the disposableStream if quit is called manually on the stream.
	 */
	action toStream() returns DisposableStream {
		return ToStream.create(self.asIObservable());
	}
	
	action catchError(IObservable onError) returns IObservable {
		Observable o := _create();
		o.onConnection := CatchError.create(onError)(onConnection);
		return o.asIObservable();
	}
	
	action retry(integer retryCount) returns IObservable {
		Observable o := _create();
		o.onConnection := Retry.create(retryCount)(onConnection);
		return o.asIObservable();
	}
	
	/**
	 * Dispose should be called once all downstreams have finished and no new connections are expected otherwise the application leaks a connection listener (Not a big deal)
	 */
	action observeOn(context observingContext, action<IObservable, action<> > observableConstructorAndDisposer) returns IDisposable {
		return ObserveOnHandler.create(observeToChannel, observeFromChannel, observingContext, observableConstructorAndDisposer);
	}
	
	action groupBy(action<any> returns any groupBy) returns IObservable {
		Observable o := _create();
		// Can't use GroupBy.create because internally it uses Subject which would cause a circular loop
		o.onConnection := GroupByOnConnection.create(_createAsIObservable, getSetOnConnection, onConnection, groupBy);
		return o.asIObservable();		
	}
	
	/**
	 * Dispose should be called once all downstreams have finished and no new connections are expected otherwise the application leaks a connection listener (Not a big deal)
	 */
	action observeToChannel(string channelName) returns IDisposable {
		return ObserveToHandler.create(onConnection, channelName);
	}

	action observeOnNewContext(action<IObservable, action<> > observableConstructorAndDisposer) returns IDisposable {
		return ObserveOnHandler.create(observeToChannel, observeFromChannel, context("ObserveOnNewContext" + integer.getUnique().toString(), false), observableConstructorAndDisposer);
	}
	
	action every(action<any> returns boolean predicate) returns IObservable {
		Observable o := _create();
		o.onConnection := Every.create(predicate)(onConnection);
		return o.asIObservable();	
	}

	action contains(action<any> returns boolean predicate) returns IObservable {
		Observable o := _create();
		o.onConnection := Contains.create(predicate)(onConnection);
		return o.asIObservable();	
	}
	
	action takeWhile(action<any> returns boolean predicate) returns IObservable {
		Observable o := _create();
		o.onConnection := TakeWhile.create(predicate)(onConnection);
		return o.asIObservable();	
	}

	action skipWhile(action<any> returns boolean predicate) returns IObservable {
		Observable o := _create();
		o.onConnection := SkipWhile.create(predicate)(onConnection);
		return o.asIObservable();	
	}
	
	action concatFromInstance(sequence<IObservable> otherObservables) returns IObservable {
		Observable o := _create();
		o.onConnection := Concat.create(otherObservables)(onConnection);
		return o.asIObservable();	
	}
	
	action startWith(sequence<any> values) returns IObservable {
		Observable o := _create();
		o.onConnection := StartWith.create(values)(onConnection);
		return o.asIObservable();	
	}
	
	action defaultIfEmpty(any defaultValue) returns IObservable {
		Observable o := _create();
		o.onConnection := DefaultIfEmpty.create(defaultValue)(onConnection);
		return o.asIObservable();	
	}
	
	action ignoreElements() returns IObservable {
		Observable o := _create();
		o.onConnection := IgnoreElements.create()(onConnection);
		return o.asIObservable();	
	}
	
	action count() returns IObservable {
		Observable o := _create();
		o.onConnection := Count.create()(onConnection);
		return o.asIObservable();
	}
	
	/**
	 * Takes any numeric type (integer, float, decimal)
	 * The result is always a float
	 */
	action sum() returns IObservable {
		Observable o := _create();
		o.onConnection := Sum.create()(onConnection);
		return o.asIObservable();
	}
	
	action sumInteger() returns IObservable {
		Observable o := _create();
		o.onConnection := SumInteger.create()(onConnection);
		return o.asIObservable();
	}
	
	action sumFloat() returns IObservable {
		Observable o := _create();
		o.onConnection := SumFloat.create()(onConnection);
		return o.asIObservable();
	}
	
	action sumDecimal() returns IObservable {
		Observable o := _create();
		o.onConnection := SumDecimal.create()(onConnection);
		return o.asIObservable();
	}
	
	/**
	 * Will use .toString() for any non-string types
	 */
	action concatString() returns IObservable {
		Observable o := _create();
		o.onConnection := ConcatString.create()(onConnection);
		return o.asIObservable();
	}
	
	/**
	 * Takes any numeric type (integer, float, decimal)
	 * The result is always a float
	 */
	action max() returns IObservable {
		Observable o := _create();
		o.onConnection := Max.create()(onConnection);
		return o.asIObservable();
	}
	
	action maxInteger() returns IObservable {
		Observable o := _create();
		o.onConnection := MaxInteger.create()(onConnection);
		return o.asIObservable();
	}
	
	action maxFloat() returns IObservable {
		Observable o := _create();
		o.onConnection := MaxFloat.create()(onConnection);
		return o.asIObservable();
	}
	
	action maxDecimal() returns IObservable {
		Observable o := _create();
		o.onConnection := MaxDecimal.create()(onConnection);
		return o.asIObservable();
	}
	
	/**
	 * Takes any numeric type (integer, float, decimal)
	 * The result is always a float
	 */
	action min() returns IObservable {
		Observable o := _create();
		o.onConnection := Min.create()(onConnection);
		return o.asIObservable();
	}
	
	action minInteger() returns IObservable {
		Observable o := _create();
		o.onConnection := MinInteger.create()(onConnection);
		return o.asIObservable();
	}
	
	action minFloat() returns IObservable {
		Observable o := _create();
		o.onConnection := MinFloat.create()(onConnection);
		return o.asIObservable();
	}
	
	action minDecimal() returns IObservable {
		Observable o := _create();
		o.onConnection := MinDecimal.create()(onConnection);
		return o.asIObservable();
	}
	
	/**
	 * Takes any numeric type (integer, float, decimal)
	 * The result is always a float
	 */
	action average() returns IObservable {
		Observable o := _create();
		o.onConnection := Average.create()(onConnection);
		return o.asIObservable();
	}
	
	/**
	 * Takes any numeric type (integer, float, decimal)
	 * The result is always a decimal
	 */
	action averageDecimal() returns IObservable {
		Observable o := _create();
		o.onConnection := AverageDecimal.create()(onConnection);
		return o.asIObservable();
	}
	
	action sequenceEqualFromInstance(sequence<IObservable> otherObservables) returns IObservable {
		Observable o := _create();		
		o.onConnection := SequenceEqual.create(otherObservables)(onConnection);
		return o.asIObservable();	
	}
	
	action ambFromInstance(sequence<IObservable> otherObservables) returns IObservable {
		Observable o := _create();		
		o.onConnection := Amb.create(otherObservables)(onConnection);
		return o.asIObservable();
	}
	
	action timestamp() returns IObservable {
		Observable o := _create();		
		o.onConnection := Timestamp.create()(onConnection);
		return o.asIObservable();
	}
	
	action updateTimestamp() returns IObservable {
		Observable o := _create();		
		o.onConnection := UpdateTimestamp.create()(onConnection);
		return o.asIObservable();
	}
	
	action timeout(float timeout) returns IObservable {
		Observable o := _create();
		o.onConnection := Timeout.create(timeout)(onConnection);
		return o.asIObservable();	
	}
	
	action getSync() returns any {
		return GetSyncHandler.create(self.asIObservable(), new any);
	}
	
	action getSyncOr(any defaultValue) returns any {		
		return GetSyncHandler.create(self.asIObservable(), defaultValue);
	}
	
	action timeInterval() returns IObservable {
		Observable o := _create();
		o.onConnection := TimeInterval.create()(onConnection);
		return o.asIObservable();	
	}
	
	action distinctUntilChanged() returns IObservable {
		Observable o := _create();
		o.onConnection := DistinctUntilChanged.create()(onConnection);
		return o.asIObservable();	
	}
	
	action distinctByUntilChanged(action<any> returns any by) returns IObservable {
		Observable o := _create();
		o.onConnection := DistinctByUntilChanged.create(by)(onConnection);
		return o.asIObservable();	
	}
	
	action switchMap(action<any> returns IObservable mapper) returns IObservable {
		Observable o := _create();
		o.onConnection := SwitchMap.create(mapper)(onConnection);
		return o.asIObservable();	
	}
	
	action debounce(float duration) returns IObservable {
		// Can't use operators.Debounce because there'd be a circular dependency on Observable.just
		return switchMap(DebounceHandler.create(duration, just));
	}
	
	action groupByWindow(IObservable trigger) returns IObservable {
		Observable o := _create();
		// Can't use operators.GroupByWindow because there'd be a circular dependency on Observable
		o.onConnection := WindowOnConnection.create(_createAsIObservable, getSetOnConnection, onConnection, trigger);
		return o.asIObservable();	
	}
	
	action throttleFirst(float throttleDuration) returns IObservable {
		Observable o := _create();
		o.onConnection := ThrottleFirst.create(throttleDuration)(onConnection);
		return o.asIObservable();	
	}
	
	action throttleLast(float throttleDuration) returns IObservable {
		Observable o := _create();
		o.onConnection := ThrottleLast.create(throttleDuration)(onConnection);
		return o.asIObservable();	
	}
	
	action sample(IObservable trigger) returns IObservable {
		// Can't use operators.sample as there would be a circular dependency on Observable
		return groupByWindow(trigger).switchMap(SampleMapper.switchMapSample);
	}
	
	action buffer(IObservable trigger) returns IObservable {
		Observable o := _create();
		o.onConnection := Buffer.create(trigger)(onConnection);
		return o.asIObservable();	
	}
	
	action bufferTime(float duration) returns IObservable {
		// Can't use operators.BufferTime as there would be a circular dependency on Observable
		return buffer(interval(duration));
	}
	
	action bufferCount(integer count) returns IObservable {
		Observable o := _create();
		o.onConnection := BufferCount.create(count)(onConnection);
		return o.asIObservable();	
	}
	
	action bufferTimeOrCount(float duration, integer count) returns IObservable {
		Observable o := _create();
		o.onConnection := BufferTimeOrCount.create(duration, count)(onConnection);
		return o.asIObservable();		
	}
	
	action combineLatestToSequenceFromInstance(sequence<IObservable> otherObservables) returns IObservable {
		Observable o := _create();		
		o.onConnection := CombineLatestToSequence.create(otherObservables)(onConnection);
		return o.asIObservable();	
	}
	
	action withLatestFromToSequence(sequence<IObservable> otherObservables) returns IObservable {
		Observable o := _create();
		o.onConnection := WithLatestFromToSequence.create(otherObservables)(onConnection);
		return o.asIObservable();	
	}
	
	action zipToSequenceFromInstance(sequence<IObservable> otherObservables) returns IObservable {
		Observable o := _create();
		o.onConnection := ZipToSequence.create(otherObservables)(onConnection);
		return o.asIObservable();
	}
	
	action windowTime(float time) returns IObservable {
		return groupByWindow(interval(time));
	}
	
	action windowCount(integer count) returns IObservable {
		// Can't use operators.BufferTime as there would be a circular dependency on Observable
		Observable o := _create();
		o.onConnection := WindowCountOnConnection.create(_createAsIObservable, getSetOnConnection, onConnection, count);
		return o.asIObservable();	

	}
	
	action windowTimeOrCount(float time, integer count) returns IObservable {
		// Can't use operators.BufferTime as there would be a circular dependency on Observable
		Observable o := _create();
		o.onConnection := WindowTimeOrCountOnConnection.create(_createAsIObservable, getSetOnConnection, onConnection, time, count);
		return o.asIObservable();	
	}
	
	action sampleTime(float time) returns IObservable {
		// Can't use operators.BufferTime as there would be a circular dependency on Observable
		return windowTime(time).switchMap(SampleMapper.switchMapSample);
	}
	
	action sampleCount(integer count) returns IObservable {
		// Can't use operators.BufferTime as there would be a circular dependency on Observable
		return windowCount(count).switchMap(SampleMapper.switchMapSample);
	}
	
	action sampleTimeOrCount(float time, integer count) returns IObservable {
		// Can't use operators.BufferTime as there would be a circular dependency on Observable
		return windowTimeOrCount(time, count).switchMap(SampleMapper.switchMapSample);
	}

	action bufferCountSkip(integer count, integer skip) returns IObservable {
		Observable o := _create();
		o.onConnection := BufferCountSkip.create(count, skip)(onConnection);
		return o.asIObservable();	
	}
	
	action pluck(string fieldName) returns IObservable {
		Observable o := _create();
		o.onConnection := Pluck.create(fieldName)(onConnection);
		return o.asIObservable();	
	}
	
	action pipe(sequence<action<action<IObserver> returns ISubscription> returns action<IObserver> returns ISubscription> pipeModifiers) returns IObservable {
		Observable o := _create();
		o.onConnection := Pipe.create(pipeModifiers)(onConnection);
		return o.asIObservable();
	}
	
	action mergeAll() returns IObservable {
		Observable o := _create();
		o.onConnection := MergeAll.create()(onConnection);
		return o.asIObservable();
	}
	
	static action invalidConnect() returns IDisposable {
		throw Exception("Can only connect a published Observable", "UnsupportedOperation");
	}
	
	action setOnConnection(action<IObserver> returns ISubscription onConnection) {
		self.onConnection := onConnection;
	}
	
	static action getSetOnConnection(IObservable o) returns action<action<IObserver> returns ISubscription> {
		return (<Observable>o.observable).setOnConnection;
	}
		
	action asIObservable() returns IObservable {
		return IObservable(self, 
		                   connectObserver, subscribe, map, publish, connect, refCount, share, take, takeLast, first, last, skip, skipLast, filter, scan, scanWithInitial, distinct, distinctBy, combineLatestFromInstance, withLatestFrom, delay, async, do, publishReplay, shareReplay, takeUntil, repeatObservable, flatMap, mergeFromInstance, zipFromInstance, switchOnNext, skipUntil, elementAt, reduce, reduceWithInitial, toStream, catchError, retry, observeOn, groupBy, observeToChannel, observeOnNewContext, every, contains, takeWhile, skipWhile, concatFromInstance, startWith, defaultIfEmpty, ignoreElements, count, sum, sumInteger, sumFloat, sumDecimal, concatString, max, maxInteger, maxFloat, maxDecimal, min, minInteger, minFloat, minDecimal, average, averageDecimal, sequenceEqualFromInstance, ambFromInstance, timestamp, updateTimestamp, timeout, getSync, getSyncOr, timeInterval, distinctUntilChanged, distinctByUntilChanged, switchMap, debounce, windowTime, throttleFirst, throttleLast, sampleTime, buffer, bufferTime, bufferCount, bufferTimeOrCount, combineLatestToSequenceFromInstance, withLatestFromToSequence, zipToSequenceFromInstance, groupByWindow, windowCount, windowTimeOrCount, sample, sampleCount, sampleTimeOrCount, bufferCountSkip, pipe, pluck, mergeAll);
	}
}