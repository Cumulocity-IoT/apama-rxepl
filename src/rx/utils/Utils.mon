package com.industry.rx_epl.utils;

using com.industry.rx_epl.utils.internal.WrapGeneric;

using com.apama.exceptions.Exception;

event Utils {
	/**
	 * Attempts to convert the provided any to a sequence of values
	 */
	static action anyToSequenceAny(any value) returns sequence<any> {
		switch(value) {
			case string: {
				return [<any>value];
			}
			default: {
				if value.getTypeName().find("optional<") = 0 {
					if value.valueToString() = "optional()" {
						return new sequence<any>;
					}
					string actualType := value.getTypeName().substring("optional<".length(), -1);
					string actualValue := value.valueToString().substring("optional(".length(), -1);
					value := any.parse("any(" + actualType + "," + actualValue + ")");
					return anyToSequenceAny(value);
				}
				return value.getEntries();
			}
		}
	}
	
	static action callAsync(action<> callback) {
		on wait(0.0) {
			callback();
		}
	}
	
	static action noOpMapper(any value) returns any {
		return value;
	}

	static action noOp() {}
	
	static action numberToFloat(any number) returns float {
		switch(number) {
			case integer: {
				return number.toFloat();
			}
			case float: {
				return number;
			}
			case decimal: {
				return number.toFloat();
			}
			default: {
				throw Exception(number.valueToString() + " is not a number", "CastError");
			}
		}
	}	
	
	static action numberToDecimal(any number) returns decimal {
		switch(number) {
			case integer: {
				return number.toDecimal();
			}
			case float: {
				return number.toDecimal();
			}
			case decimal: {
				return number;
			}
			default: {
				throw Exception(number.valueToString() + " is not a number", "CastError");
			}
		}
	}
	
	static action waitJustUnder(float waitTime) returns float {
		float endTime := currentTime + waitTime;
		return waitTime - (endTime - endTime.nextafter(0.0));
	}
	
}

event Actions {
	action<sequence<any> > returns any genericAction;
	sequence<string> types;
	dictionary<string, action<any> returns any> coercingfunctions;
	
	static action getCoercingGenericAction(any actionAny) returns action<sequence<any> > returns any {
		return Actions(actionAny.getGenericAction(), getActionParamTypes(actionAny), {
			"string": coerceToString,
			"integer": coerceToInteger,
			"float": coerceToFloat,
			"decimal": coerceToDecimal
		}).coerceAndCall;
	}
	
	static action checkAction(any actionAny, integer args, integer optionalArgs, string returnType) {		
		if actionAny.getTypeName().find("action<") != 0 {
			throw Exception("Did not provide an action, was: " + actionAny.getTypeName(), "IllegalArgumentException");
		}
		
		integer argCount := actionAny.getActionParameterNames().size();
		if argCount < args or argCount > args + optionalArgs {
			throw Exception("Incorrect action, provided action needed " + args.toString() + " Args and optionally " + optionalArgs.toString() + " Optional Args, actually had: " + argCount.toString(), "IllegalArgumentException");
		}
		
		string actualReturnType := actionAny.getActionReturnTypeName();
		if (returnType = "any" and actualReturnType = "") or (actualReturnType != returnType and returnType != "" and returnType != "any") {
			throw Exception("Incorrect action, must have a return value of type " + returnType + " was " + actualReturnType, "IllegalArgumentException");
		}
	}
	
	static action getActionParamTypes(any someAction) returns sequence<string> {
		sequence<string> result := new sequence<string>;
		dictionary<string, string> typeNamesByParamName := someAction.getActionParameters();
		string name;
		for name in someAction.getActionParameterNames() {
			result.append(typeNamesByParamName[name]);
		}
		return result;
	}
	
	action coerceAndCall(sequence<any> args) returns any {
		sequence<any> coercedValues := new sequence<any>;
		integer i := 0;
		while i < types.size() {
			string type := types[i];
			any value := args[i];
			if coercingfunctions.hasKey(type) {
				value := coercingfunctions[type](value);
			}
			coercedValues.append(args[i]);
			i := i + 1;
		}
		return genericAction(coercedValues);
	}

	static action coerceToString(any value) returns any {
		switch(value) {
			case string: {
				return value;
			}
			default: {
				return value.valueToString();
			}
		}
	}
	static action coerceToInteger(any value) returns any {
		switch(value) {
			case integer: {
				return value;
			}
			case float: {
				if value > 0.0 {
					return value.floor(); 
				} else {
					return value.ceil();
				}
			}
			case decimal: {
				if value > 0.0d {
					return value.floor(); 
				} else {
					return value.ceil();
				}
			}
			default: {
				throw Exception("Unable to coerce " + value.toString() + " to integer", "IllegalArgumentException");
			}
		}
	}
	static action coerceToFloat(any value) returns any {
		switch(value) {
			case integer: {
				return value.toFloat();
			}
			case float: {
				return value;
			}
			case decimal: {
				return value.toFloat();
			}
			default: {
				throw Exception("Unable to coerce " + value.toString() + " to float", "IllegalArgumentException");
			}
		}
	}
	static action coerceToDecimal(any value) returns any {
		switch(value) {
			case integer: {
				return value.toDecimal();
			}
			case float: {
				return value.toDecimal();
			}
			case decimal: {
				return value;
			}
			default: {
				throw Exception("Unable to coerce " + value.toString() + " to decimal", "IllegalArgumentException");
			}
		}
	}
}